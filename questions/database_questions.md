# Вопросы по Базам данных

_Примечание_ - *Далее словосочетание база данных сокращено как БД.*

___

<details> 
<summary><strong>Что такое БД?</strong></summary>

База данных - совокупность данных, которая отражает состояние объектов и их
отношений в рассматриваемой предметной области.

Простыми словами БД - данные организованные по определённым условиям и схемам.

</details>

<details> 
<summary><strong>Какие типы БД существуют?</strong></summary>

Типы БД представляют собой шаблоны и структуры организации хранения
данных и их управлением. Наиболее известны следующие типы БД:

- Иерархические БД (*пример - файловая система*).   
  В иерархических БД каждая запись имеет **одного** «родителя».
  Это создаёт древовидную структуру, в которой записи классифицируются по их
  отношениям с цепочкой родительских записей.
- Сетевые БД.(*пример - IDMS*)  
  Такой тип БД является расширением иерархического, — также есть строгая
  иерархия отношений, но записи могут иметь **более одного** «родителя».
- Реляционные БД.(*пример - PostgreSQL*)  
  Данные и связи между данными организованы с помощью таблиц. Каждый столбец
  в таблице имеет имя и тип. Каждая строка представляет отдельную запись или
  элемент данных в таблице, который содержит значения для каждого из столбцов.
  К таблицам в таких БД применяют различные уровни нормализации формы.

  > Нормальная форма — требование, предъявляемое к структуре таблиц в теории реляционных баз данных для устранения из
  базы избыточных функциональных зависимостей между атрибутами (полями таблиц).

- NoSQL БД (*пример - MongoDB*).   
  Типы БД, предлагающих подходы, отличные от стандартного реляционного шаблона.
  Базы данных таких типов оптимизированы для приложений, которые работают
  с большим объемом данных, нуждаются в низкой задержке и гибких моделях данных.
  В таких БД зачастую:
    * не используется стандарт SQL;
    * структура данных неструктурированна.
- БД «ключ-значение» (*пример - Redis*).   
  Для хранения информации предоставляется ключ и объект данных,
  который нужно сохранить.

_Примечание_ - Существуют еще много иных типов
БД (графовая, колоночная, NewSQL). Однако зачастую идёт либо сочетание свойств,
либо добавление определённой структуры вышеперечисленных БД.

</details>

<details> 
<summary>
    <strong>Как на уровне реляционных БД реализуется связь <mark>many to many</mark>?</strong>
</summary>

Если есть модели `A` и `B` со связью многие ко многим, то создается
таблица-мост, которая хранит ключ на `A`, ключ на `B`.

</details>

<details> 
<summary><strong>Что такое индексы и как они работают?</strong></summary>

Индекс - объект позволяющий увеличить производительность поиска
в БД (*предоставляет путь для быстрого поиска данных на основе значений в столбцах*).
Зачастую индексы реализуется как бинарное дерево. Их работа
производиться (*в грубой форме*) так:

- При создании индекса формируется объект отвечающий за упорядочивание строк в таблице;
- Для каждого индекса формируется свой объект;
- При добавлении или удалении значений в таблице идёт перестройка каждого объекта индекса;
- Каждое новое поле в индексе (*он может быть составным*) увеличивает размер ключа,
  поэтому чем меньше полей, тем быстрее.

> Индексы ускоряют запросы, но увеличивают затраты по памяти и замедляют вставки.
</details>

<details> 
<summary><strong>Что такое транзакция?</strong></summary>

Транзакция — это набор операций по работе с БД, объединенных в одну атомарную
пачку. Данные запросы или выполняются группой (*без ошибок*) и происходит `COMMIT`,
или не выполняются и производиться `ROLLBACK`.

Если говорить по-научному, то транзакция — упорядоченное множество операций,
переводящих базу данных из одного согласованного состояния в другое.   
Согласованное состояние — это состояние, которое подходит под бизнес-логику системы.

</details>

<details> 
<summary><strong>Что такое уровень изоляции транзакции?</strong></summary>

Изолированность транзакции показывает насколько сильно влияют друг на друга
параллельно выполняющиеся транзакции.
Существуют несколько уровней изоляции:

- `Read uncommitted` (*каждая транзакция видит незафиксированные изменения другой транзакции*);
- `Read committed` (*параллельно исполняющиеся транзакции видят только*
  *зафиксированные изменения из других транзакций*);
- `Repeatable read` (*мы не видим в исполняющейся транзакции измененные и*
  *удаленные записи другой транзакции, но все еще видим вставленные записи*
  *из другой транзакции*);
- `Serializable` (*транзакции ведут себя как будто ничего более не существует*).

> Разные БД по-разному воспринимают уровни изолированности.

</details>

<details> 
<summary>
    <strong>Когда использовать реляционные, а когда нереляционные БД?</strong>
</summary>

**SQL чаще выбирают когда:**

- Необходимо соответствие БД требованиям
  ACID (*атомарность, непротиворечивость, изолированность, долговечность*).
- Данные, с которыми вы работаете, структурированы,
  при этом структура не подвержена частым изменением.
- Необходима более защищённая БД.
- Нужен хороший контроль транзакций.

**NoSQL чаще выбирают когда:**

- Требуется хранение больших объёмов неструктурированной информации.
- Использование облачных вычислений и хранилищ.
- Когда большинство запросов простые и работают с
  графоподобными данными (*данными получаемыми по времени*).

</details>

<details> 
<summary><strong>Как можно оптимизировать запросы?</strong></summary>


Несколько советов для оптимизации запросов:

1. Не читайте больше данных, чем надо (*не используйте `*`*).
2. Если имеете две или более таблиц, которые часто объединяются вместе,
   тогда столбцы, используемые для объединений должны иметь соответствующий индекс.
3. Для лучшей производительности, столбцы, используемые в объединениях должны
   иметь одинаковые типы данных. И если возможно, это должны быть числовые
   типы данных, вместо символьных типов.
4. Тип `JOIN` используйте только тот, который вернет вам **необходимые** данные.
5. Используйте как можно меньше колонок для группировки.
6. Если `Where` состоит из условий, объединенных `AND`, они должны располагаться
   в порядке возрастания вероятности истинности данного условия.
7. По возможности лучше использовать `Where` вместо `Having`, т.к. это
   уменьшает количество строк для группировки на ранней стадии.

</details>

